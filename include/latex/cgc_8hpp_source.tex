\hypertarget{cgc_8hpp_source}{}\doxysection{cgc.\+hpp}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*******************************************************************************************}}
\DoxyCodeLine{2 \textcolor{comment}{some of "{}cgc.h"{} meathods implementation.}}
\DoxyCodeLine{3 \textcolor{comment}{    }}
\DoxyCodeLine{4 \textcolor{comment}{by:  Mohammed Maher Abdelrahim Mohammed}}
\DoxyCodeLine{5 \textcolor{comment}{     UNIVERSITÀ DELLA CALABRIA, DIPARTIMENTO DI FISICA AND INFN-\/COSENZA}}
\DoxyCodeLine{6 \textcolor{comment}{     VIA P. BUCCI, CUBO 31 C, I-\/87036 COSENZA, ITALY}}
\DoxyCodeLine{7 \textcolor{comment}{     mohammed.maher@unical.it                                          }}
\DoxyCodeLine{8 \textcolor{comment}{*******************************************************************************************/}}
\DoxyCodeLine{9 \textcolor{comment}{//\#pragma once}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#ifndef QUANTAPLUS\_INCLUDE\_CGC\_HPP}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#define QUANTAPLUS\_INCLUDE\_CGC\_HPP}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#ifndef QUANTAPLUS\_INCLUDE\_CGC\_HPP}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#error \_\_FILE\_\_ should only be included from cgc.h.}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CGC\_H}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{18 \textcolor{comment}{  Function: SquareRoot  }}
\DoxyCodeLine{19 \textcolor{comment}{}}
\DoxyCodeLine{20 \textcolor{comment}{  Summary: gives the given current value if  it's equivalent to given previous one, else it}}
\DoxyCodeLine{21 \textcolor{comment}{  will recursively call it self. }}
\DoxyCodeLine{22 \textcolor{comment}{        }}
\DoxyCodeLine{23 \textcolor{comment}{  Args: const double\& x}}
\DoxyCodeLine{24 \textcolor{comment}{        }}
\DoxyCodeLine{25 \textcolor{comment}{    const double\& curr}}
\DoxyCodeLine{26 \textcolor{comment}{        }}
\DoxyCodeLine{27 \textcolor{comment}{    const double\& prev  }}
\DoxyCodeLine{28 \textcolor{comment}{          }}
\DoxyCodeLine{29 \textcolor{comment}{  Returns:  double}}
\DoxyCodeLine{30 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{31 \textcolor{keywordtype}{double} SquareRoot(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& x, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& curr, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& prev)}
\DoxyCodeLine{32 \{}
\DoxyCodeLine{33         \textcolor{keywordflow}{return} curr == prev}
\DoxyCodeLine{34                ? curr}
\DoxyCodeLine{35                : SquareRoot(x, 0.5 * (curr + x / curr), curr);}
\DoxyCodeLine{36 \}}
\DoxyCodeLine{37 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ overloaded SquareRoot -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{38 \textcolor{keywordtype}{double} SquareRoot(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& x)}
\DoxyCodeLine{39 \{}
\DoxyCodeLine{40     \textcolor{keywordflow}{return} x >= 0 \&\& x < std::numeric\_limits<double>::infinity()}
\DoxyCodeLine{41                ? SquareRoot(x, x, 0)}
\DoxyCodeLine{42                : std::numeric\_limits<double>::quiet\_NaN();}
\DoxyCodeLine{43 \}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{46 \textcolor{comment}{  Function: Factorial }}
\DoxyCodeLine{47 \textcolor{comment}{}}
\DoxyCodeLine{48 \textcolor{comment}{  Summary:  Factorial of an positive integer.  }}
\DoxyCodeLine{49 \textcolor{comment}{        }}
\DoxyCodeLine{50 \textcolor{comment}{  Args:  const std::size\_t\& n}}
\DoxyCodeLine{51 \textcolor{comment}{         positive integer.     }}
\DoxyCodeLine{52 \textcolor{comment}{          }}
\DoxyCodeLine{53 \textcolor{comment}{  Returns: std::size\_t}}
\DoxyCodeLine{54 \textcolor{comment}{        large integer.}}
\DoxyCodeLine{55 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{56 \textcolor{comment}{/*std::size\_t Factorial(const std::size\_t\& n)}}
\DoxyCodeLine{57 \textcolor{comment}{\{}}
\DoxyCodeLine{58 \textcolor{comment}{        return n == 0? 1 : n * Factorial(n-\/1);}}
\DoxyCodeLine{59 \textcolor{comment}{\}*/}}
\DoxyCodeLine{60 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/overloaded Factorial -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{61 \textcolor{keywordtype}{double} Factorial(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& n)}
\DoxyCodeLine{62 \{}
\DoxyCodeLine{63         \textcolor{keywordflow}{return} n == 0? 1 : n * Factorial(n-\/1);}
\DoxyCodeLine{64 \}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{67 \textcolor{comment}{  Function: FracFactorial }}
\DoxyCodeLine{68 \textcolor{comment}{}}
\DoxyCodeLine{69 \textcolor{comment}{  Summary:  Factorial of fractional numbers (using gamma functions) }}
\DoxyCodeLine{70 \textcolor{comment}{        }}
\DoxyCodeLine{71 \textcolor{comment}{  Args: const double\& n}}
\DoxyCodeLine{72 \textcolor{comment}{        fractional number     }}
\DoxyCodeLine{73 \textcolor{comment}{          }}
\DoxyCodeLine{74 \textcolor{comment}{  Returns:  double}}
\DoxyCodeLine{75 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{76 \textcolor{keywordtype}{double} FracFactorial(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& n)}
\DoxyCodeLine{77 \{  }
\DoxyCodeLine{78     \textcolor{keywordflow}{return} tgamma(n+1.);}
\DoxyCodeLine{79 \}}
\DoxyCodeLine{80 }
\DoxyCodeLine{81 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{82 \textcolor{comment}{  Function: ClebschGordan }}
\DoxyCodeLine{83 \textcolor{comment}{}}
\DoxyCodeLine{84 \textcolor{comment}{  Summary: Calculation of the Clebsch–Gordan Coefficients Generalized power series representations. }}
\DoxyCodeLine{85 \textcolor{comment}{        }}
\DoxyCodeLine{86 \textcolor{comment}{  Args:      }}
\DoxyCodeLine{87 \textcolor{comment}{          }}
\DoxyCodeLine{88 \textcolor{comment}{  Returns:  }}
\DoxyCodeLine{89 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{90 \textcolor{keywordtype}{double} ClebschGordan(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j1, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j2, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& m1, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& m2, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& J, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& M)\{}
\DoxyCodeLine{91     \textcolor{keywordflow}{if}( !validAngularMomentum(j1) || !validAngularMomentum(m1) || !validAngularMomentum(j2) || !validAngularMomentum(m2) || !validAngularMomentum(J) )\{}
\DoxyCodeLine{92         \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}clebsch\_gordan: all parameters must be multiples of 0.5."{}});}
\DoxyCodeLine{93     \}}
\DoxyCodeLine{94     \textcolor{keywordflow}{if}( (validInteger(j1) \&\& halfInteger(m1)) || (halfInteger(j1) \&\& validInteger(m1)) )\{}
\DoxyCodeLine{95         \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}clebsch\_gordan: j1 and m1 must both be integral or half integral."{}});}
\DoxyCodeLine{96     \}}
\DoxyCodeLine{97     \textcolor{keywordflow}{if}( (validInteger(j2) \&\& halfInteger(m2)) || (halfInteger(j2) \&\& validInteger(m2)) )\{}
\DoxyCodeLine{98         \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}clebsch\_gordan: j2 and m2 must both be integral or half integral."{}});}
\DoxyCodeLine{99     \}}
\DoxyCodeLine{100     \textcolor{keywordflow}{if}( (validInteger(j1 + j2) \&\& !validInteger(J)) || (halfInteger(j1 + j2) \&\& !halfInteger(J)) )\{}
\DoxyCodeLine{101         \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}clebsch\_gordan: J is no valid value for j1 and j2 combination."{}});}
\DoxyCodeLine{102     \}}
\DoxyCodeLine{103     \textcolor{keywordflow}{if}( j1 < 0 || j2 < 0 )\{}
\DoxyCodeLine{104         \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}clebsch\_gordan: j1 and j2 must be non-\/negative."{}});}
\DoxyCodeLine{105     \}}
\DoxyCodeLine{106     \textcolor{keywordflow}{if}( J > j1 + j2 || J < abs(j1 -\/ j2) )\{}
\DoxyCodeLine{107         \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}clebsch\_gordan: J must be |j1-\/j2| <= J <= j1+j2."{}});}
\DoxyCodeLine{108     \}}
\DoxyCodeLine{109     \textcolor{keywordflow}{if}( abs(m1) > j1 || abs(m2) > j2 || abs(M) > J )\{}
\DoxyCodeLine{110         \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}clebsch\_gordan: m1 and m2 must be |m1| <= j1 and |m2| <= j2 and |m1+m2| <= J"{}});}
\DoxyCodeLine{111     \}}
\DoxyCodeLine{112     \textcolor{keywordflow}{if}( m1 + m2 != M )\{}
\DoxyCodeLine{113         \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}clebsch\_gordan: m1 + m2 != M."{}});}
\DoxyCodeLine{114     \} }
\DoxyCodeLine{115 }
\DoxyCodeLine{116     \textcolor{comment}{//auto const \& f = Factorial;}}
\DoxyCodeLine{117     \textcolor{keywordtype}{double} numerator = (2 * J + 1) * Factorial(J + j1 -\/ j2) * Factorial(J -\/ j1 + j2) * Factorial(j1 + j2 -\/ J);}
\DoxyCodeLine{118     numerator *= Factorial(J + M) * Factorial(J -\/ M) * Factorial(j1 -\/ m1) * Factorial(j1 + m1) * Factorial(j2 -\/ m2) * Factorial(j2 + m2);}
\DoxyCodeLine{119     \textcolor{keywordtype}{double} denominator = Factorial(j1 + j2 + J + 1);}
\DoxyCodeLine{120     }
\DoxyCodeLine{121     \textcolor{keywordtype}{int} \textcolor{keyword}{const} min = std::max(0., std::max(j2 -\/ J -\/ m1, j1 + m2 -\/ J));}
\DoxyCodeLine{122     \textcolor{keywordtype}{int} \textcolor{keyword}{const} max = std::min(j2 + m2, std::min(j1 -\/ m1, j1 + j2 -\/ J));}
\DoxyCodeLine{123     \textcolor{keywordtype}{double} sum = min > max ? 1 : 0;}
\DoxyCodeLine{124     }
\DoxyCodeLine{125     \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} k = min; k <= max; ++k )\{}
\DoxyCodeLine{126         sum += pow(-\/1., k) / (Factorial(k) * Factorial(j1 + j2 -\/ J -\/ k) * Factorial(j1 -\/ m1 -\/ k) * Factorial(j2 + m2 -\/ k) * Factorial(J -\/ j2 + m1 + k) * Factorial(J -\/ j1 -\/ m2 + k));}
\DoxyCodeLine{127     \}}
\DoxyCodeLine{128     \textcolor{keywordflow}{return} SquareRoot(numerator / denominator) * sum;}
\DoxyCodeLine{129 \}}
\DoxyCodeLine{130 }
\DoxyCodeLine{131 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/overloaded ClebschGordan function -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{132 \textcolor{keywordtype}{double} ClebschGordan(\textcolor{keyword}{const} CGCcoeff\& cgc)\{}
\DoxyCodeLine{133 }
\DoxyCodeLine{134 }
\DoxyCodeLine{135     \textcolor{keywordflow}{return} ClebschGordan(cgc.j1,cgc.j2,cgc.m1,cgc.m2,cgc.j,cgc.m);}
\DoxyCodeLine{136 \}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{139 \textcolor{comment}{  Function: MQuantumNumber}}
\DoxyCodeLine{140 \textcolor{comment}{}}
\DoxyCodeLine{141 \textcolor{comment}{  Summary: calculate the possible magnetic quantum number m for given}}
\DoxyCodeLine{142 \textcolor{comment}{       spin of length j.  }}
\DoxyCodeLine{143 \textcolor{comment}{        }}
\DoxyCodeLine{144 \textcolor{comment}{  Args: const double \&j}}
\DoxyCodeLine{145 \textcolor{comment}{        the length of the spin quantum number.    }}
\DoxyCodeLine{146 \textcolor{comment}{          }}
\DoxyCodeLine{147 \textcolor{comment}{  Returns:  std::vector<double>}}
\DoxyCodeLine{148 \textcolor{comment}{        list of all possible m values.}}
\DoxyCodeLine{149 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{150 std::vector<double> MQuantumNumber(\textcolor{keyword}{const} \textcolor{keywordtype}{double} \&j)}
\DoxyCodeLine{151 \{    }
\DoxyCodeLine{152     \textcolor{keywordtype}{double} spin = j;}
\DoxyCodeLine{153     std::vector<double> m\_values;}
\DoxyCodeLine{154     \textcolor{keywordflow}{if}(validAngularMomentum(spin))}
\DoxyCodeLine{155     \{}
\DoxyCodeLine{156         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i =-\/j; i<=j; i++)}
\DoxyCodeLine{157         \{       }
\DoxyCodeLine{158             \textcolor{keywordflow}{if}(i==0)\{m\_values.push\_back(0);\}}
\DoxyCodeLine{159             \textcolor{keywordflow}{else} m\_values.push\_back(i);  }
\DoxyCodeLine{160         \}}
\DoxyCodeLine{161     \}}
\DoxyCodeLine{162     \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{163         \textcolor{keywordflow}{throw} std::invalid\_argument(\textcolor{stringliteral}{"{}the system has physically invalid spin!."{}});}
\DoxyCodeLine{164     \}   }
\DoxyCodeLine{165     \textcolor{keywordflow}{return} m\_values;}
\DoxyCodeLine{166 \}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{169 \textcolor{comment}{  Function: possibleJ  }}
\DoxyCodeLine{170 \textcolor{comment}{}}
\DoxyCodeLine{171 \textcolor{comment}{  Summary: calculate the possible total angular momenta values   }}
\DoxyCodeLine{172 \textcolor{comment}{        }}
\DoxyCodeLine{173 \textcolor{comment}{  Args: const double\& j1}}
\DoxyCodeLine{174 \textcolor{comment}{        first angular momentum. }}
\DoxyCodeLine{175 \textcolor{comment}{    const double\& j2}}
\DoxyCodeLine{176 \textcolor{comment}{        second angular momentum.     }}
\DoxyCodeLine{177 \textcolor{comment}{          }}
\DoxyCodeLine{178 \textcolor{comment}{  Returns: std::vector<double>}}
\DoxyCodeLine{179 \textcolor{comment}{        list of all possible  total angular momenta J values.}}
\DoxyCodeLine{180 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{181 std::vector<double> possibleJ(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j1, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j2)\{}
\DoxyCodeLine{182 }
\DoxyCodeLine{183     \textcolor{keywordtype}{double} Jmin = std::abs(j1-\/j2);}
\DoxyCodeLine{184     \textcolor{keywordtype}{double} Jmax = j1+j2;}
\DoxyCodeLine{185     std::vector<double> J\_values;}
\DoxyCodeLine{186     \textcolor{keywordflow}{if}(validAngularMomentum(j1) \&\& validAngularMomentum(j2))}
\DoxyCodeLine{187     \{}
\DoxyCodeLine{188         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i =Jmin; i<=Jmax; i++)}
\DoxyCodeLine{189         \{       }
\DoxyCodeLine{190             \textcolor{keywordflow}{if}(i==0)\{J\_values.push\_back(0);\}}
\DoxyCodeLine{191             \textcolor{keywordflow}{else} J\_values.push\_back(i);  }
\DoxyCodeLine{192         \}}
\DoxyCodeLine{193     \}}
\DoxyCodeLine{194     \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{195         \textcolor{keywordflow}{throw} std::invalid\_argument(\textcolor{stringliteral}{"{}the system has physically invalid spin!."{}});}
\DoxyCodeLine{196     \}}
\DoxyCodeLine{197     \textcolor{keywordflow}{return} J\_values;}
\DoxyCodeLine{198 \}}
\DoxyCodeLine{199 }
\DoxyCodeLine{200 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{201 \textcolor{comment}{  Function: ListOfAllCGCs}}
\DoxyCodeLine{202 \textcolor{comment}{}}
\DoxyCodeLine{203 \textcolor{comment}{  Summary: calculate all Clebsch–Gordan Coefficients for addition of two angular}}
\DoxyCodeLine{204 \textcolor{comment}{       momenta. }}
\DoxyCodeLine{205 \textcolor{comment}{        }}
\DoxyCodeLine{206 \textcolor{comment}{  Args: const double\& j1}}
\DoxyCodeLine{207 \textcolor{comment}{        first angular momentum. }}
\DoxyCodeLine{208 \textcolor{comment}{    const double\& j2}}
\DoxyCodeLine{209 \textcolor{comment}{        second angular momentum.      }}
\DoxyCodeLine{210 \textcolor{comment}{          }}
\DoxyCodeLine{211 \textcolor{comment}{  Returns:  void}}
\DoxyCodeLine{212 \textcolor{comment}{        print the list of all Clebsch–Gordan Coefficients.}}
\DoxyCodeLine{213 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{214 \textcolor{keywordtype}{void} ListOfAllCGCs(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j1, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j2)}
\DoxyCodeLine{215 \{}
\DoxyCodeLine{216     std::vector<double> J = possibleJ(j1,j2);}
\DoxyCodeLine{217     std::vector<double> M;  }
\DoxyCodeLine{218  }
\DoxyCodeLine{219     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& j : J)\{}
\DoxyCodeLine{220         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i =0;i<int(2*j+1);i++)\{}
\DoxyCodeLine{221             M.push\_back(MQuantumNumber(j)[i]);}
\DoxyCodeLine{222         \}}
\DoxyCodeLine{223     \}}
\DoxyCodeLine{224     std::cout<<\textcolor{stringliteral}{"{}-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/"{}}<<std::endl;}
\DoxyCodeLine{225     std::cout<<\textcolor{stringliteral}{"{}Clebsch-\/Gordon coefficients for system with j1 = "{}};}
\DoxyCodeLine{226     DecimalToFraction(j1);}
\DoxyCodeLine{227     std::cout<<\textcolor{stringliteral}{"{} and j2 = "{}};}
\DoxyCodeLine{228     DecimalToFraction(j2);}
\DoxyCodeLine{229     std::cout<<\textcolor{stringliteral}{"{} :"{}}<<std::endl;}
\DoxyCodeLine{230     std::cout<<\textcolor{stringliteral}{"{}-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/"{}}<<std::endl;}
\DoxyCodeLine{231     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& jj : J)\{}
\DoxyCodeLine{232         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} m = -\/jj; m <= jj; ++m)\{}
\DoxyCodeLine{233             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} m1 = -\/j1; m1 <= j1; ++m1) \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} m2 = -\/j2; m2 <= j2; ++m2)\{}
\DoxyCodeLine{234                 \textcolor{keywordflow}{if}( (-\/jj <= std::abs(m1+m2)) \&\& (std::abs(m1+m2) <= jj) \&\& ( (m1+m2) == m) )\{}
\DoxyCodeLine{235                     std::cout<<\textcolor{stringliteral}{"{}<"{}};}
\DoxyCodeLine{236                     DecimalToFraction(j1);}
\DoxyCodeLine{237                     std::cout<<\textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{238                     DecimalToFraction(j2);}
\DoxyCodeLine{239                     std::cout<<\textcolor{stringliteral}{"{}; "{}};}
\DoxyCodeLine{240                     DecimalToFraction(m1);}
\DoxyCodeLine{241                     std::cout<<\textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{242                     DecimalToFraction(m2);}
\DoxyCodeLine{243                     std::cout<<\textcolor{stringliteral}{"{} | "{}};}
\DoxyCodeLine{244                     DecimalToFraction(jj);}
\DoxyCodeLine{245                     std::cout<<\textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{246                     DecimalToFraction(m1+m2);}
\DoxyCodeLine{247                     std::cout<<\textcolor{stringliteral}{"{}> = "{}};}
\DoxyCodeLine{248                     std::cout<<\textcolor{stringliteral}{"{} = "{}};}
\DoxyCodeLine{249                     DecimalToFraction(ClebschGordan(j1,j2,m1,m2,jj,m));}
\DoxyCodeLine{250                     std::cout<<std::endl;}
\DoxyCodeLine{251                 \}}
\DoxyCodeLine{252             \}   }
\DoxyCodeLine{253         \}}
\DoxyCodeLine{254     \} }
\DoxyCodeLine{255 \}}
\DoxyCodeLine{256 }
\DoxyCodeLine{257 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{258 \textcolor{comment}{  Function: CGCcoeffMap  }}
\DoxyCodeLine{259 \textcolor{comment}{}}
\DoxyCodeLine{260 \textcolor{comment}{  Summary: store Clebsch–Gordan Coefficients as a map  }}
\DoxyCodeLine{261 \textcolor{comment}{        }}
\DoxyCodeLine{262 \textcolor{comment}{  Args: const double\& j1}}
\DoxyCodeLine{263 \textcolor{comment}{        first angular momentum. }}
\DoxyCodeLine{264 \textcolor{comment}{    const double\& j2}}
\DoxyCodeLine{265 \textcolor{comment}{        second angular momentum.      }}
\DoxyCodeLine{266 \textcolor{comment}{          }}
\DoxyCodeLine{267 \textcolor{comment}{  Returns: std::map<CGCcoeff, std::vector<CGCcoeff>> }}
\DoxyCodeLine{268 \textcolor{comment}{        mapping each GCcoeff to its all possible values}}
\DoxyCodeLine{269 \textcolor{comment}{        stored as vector.}}
\DoxyCodeLine{270 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{271 std::map<CGCcoeff, std::vector<CGCcoeff>>  CGCcoeffMap (\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j1, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j2)}
\DoxyCodeLine{272 \{  }
\DoxyCodeLine{273         std::map<CGCcoeff, std::vector<CGCcoeff>> CGCs;}
\DoxyCodeLine{274     std::vector<double> J = possibleJ(j1,j2);}
\DoxyCodeLine{275     std::vector<double> M;  }
\DoxyCodeLine{276  }
\DoxyCodeLine{277     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& j : J)\{}
\DoxyCodeLine{278         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i =0;i<int(2*j+1);i++)\{}
\DoxyCodeLine{279             M.push\_back(MQuantumNumber(j)[i]);}
\DoxyCodeLine{280         \}}
\DoxyCodeLine{281     \}}
\DoxyCodeLine{282         }
\DoxyCodeLine{283     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& jj : J)\{}
\DoxyCodeLine{284         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} m = -\/jj; m <= jj; ++m)\{}
\DoxyCodeLine{285             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} m1 = -\/j1; m1 <= j1; ++m1) \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} m2 = -\/j2; m2 <= j2; ++m2)\{}
\DoxyCodeLine{286                 \textcolor{keywordflow}{if}( (-\/jj <= std::abs(m1+m2)) \&\& (std::abs(m1+m2) <= jj) \&\& ( (m1+m2) == m) )\{}
\DoxyCodeLine{287                     CGCs[CGCcoeff(jj,m1+m2)].push\_back(CGCcoeff(j1,j2,m1,m2,jj,m1+m2));      }
\DoxyCodeLine{288                 \}   }
\DoxyCodeLine{289             \}}
\DoxyCodeLine{290         \}    }
\DoxyCodeLine{291     \}}
\DoxyCodeLine{292     \textcolor{keywordflow}{return} CGCs;}
\DoxyCodeLine{293 \}}
\DoxyCodeLine{294 }
\DoxyCodeLine{295 \textcolor{comment}{/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++}}
\DoxyCodeLine{296 \textcolor{comment}{  Function:  CoupledStates }}
\DoxyCodeLine{297 \textcolor{comment}{}}
\DoxyCodeLine{298 \textcolor{comment}{  Summary: List the states of the coupled system.}}
\DoxyCodeLine{299 \textcolor{comment}{        }}
\DoxyCodeLine{300 \textcolor{comment}{  Args: const double\& j1}}
\DoxyCodeLine{301 \textcolor{comment}{        first angular momentum. }}
\DoxyCodeLine{302 \textcolor{comment}{    const double\& j2}}
\DoxyCodeLine{303 \textcolor{comment}{        second angular momentum.     }}
\DoxyCodeLine{304 \textcolor{comment}{          }}
\DoxyCodeLine{305 \textcolor{comment}{  Returns: void}}
\DoxyCodeLine{306 \textcolor{comment}{        print the list of all states of the coupled system.}}
\DoxyCodeLine{307 \textcolor{comment}{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{308 \textcolor{keywordtype}{void} CoupledStates(\textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j1, \textcolor{keyword}{const} \textcolor{keywordtype}{double}\& j2)}
\DoxyCodeLine{309 \{   }
\DoxyCodeLine{310     std::map<CGCcoeff, std::vector<CGCcoeff>> res = CGCcoeffMap(j1,j2);}
\DoxyCodeLine{311     std::cout<<\textcolor{stringliteral}{"{}-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/"{}}<<std::endl;}
\DoxyCodeLine{312     std::cout<<\textcolor{stringliteral}{"{}The states of the coupled system "{}};}
\DoxyCodeLine{313     DecimalToFraction(j1);}
\DoxyCodeLine{314     std::cout<<\textcolor{stringliteral}{"{} + "{}};}
\DoxyCodeLine{315     DecimalToFraction(j2);}
\DoxyCodeLine{316     std::cout<<\textcolor{stringliteral}{"{} :"{}}<<std::endl;}
\DoxyCodeLine{317     std::cout<<\textcolor{stringliteral}{"{}-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/"{}}<<std::endl;}
\DoxyCodeLine{318     }
\DoxyCodeLine{319     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} itr = res.begin(); itr!=res.end(); itr++) \{}
\DoxyCodeLine{320 }
\DoxyCodeLine{321         std::cout <<\textcolor{stringliteral}{"{}|"{}};DecimalToFraction(itr-\/>first.j); std::cout<< \textcolor{stringliteral}{"{}, "{}};DecimalToFraction(itr-\/>first.m);std::cout<<\textcolor{stringliteral}{"{}>"{}}<< \textcolor{stringliteral}{"{} = "{}};}
\DoxyCodeLine{322 }
\DoxyCodeLine{323         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} vitr = itr-\/>second.begin(); vitr != itr-\/>second.end(); vitr++)\{}
\DoxyCodeLine{324 }
\DoxyCodeLine{325             \textcolor{keywordflow}{if}(ClebschGordan(*vitr)!=0)\{}
\DoxyCodeLine{326                 }
\DoxyCodeLine{327                 std::cout<<\textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{328                 DecimalToFraction(ClebschGordan(*vitr));}
\DoxyCodeLine{329                 }
\DoxyCodeLine{330                 \textcolor{keywordflow}{if}(vitr==itr-\/>second.end()-\/1)\{}
\DoxyCodeLine{331                     std::cout<<\textcolor{stringliteral}{"{} \} "{}}<<*vitr;}
\DoxyCodeLine{332                 \}}
\DoxyCodeLine{333                 \textcolor{keywordflow}{else} std::cout<<\textcolor{stringliteral}{"{} \} "{}}<<*vitr<<\textcolor{stringliteral}{"{} + "{}};}
\DoxyCodeLine{334             \}}
\DoxyCodeLine{335 }
\DoxyCodeLine{336         \}}
\DoxyCodeLine{337         std::cout<<std::endl;}
\DoxyCodeLine{338     \} }
\DoxyCodeLine{339 \}}
\DoxyCodeLine{340 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CGC\_HPP}}

\end{DoxyCode}
